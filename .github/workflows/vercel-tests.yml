name: Test Suite

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']
  deployment_status:
    # Keep for backwards compatibility, but most logic moved to push workflow

jobs:
  # Run unit tests on every push and PR
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
      statuses: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20.x
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      id: test
      run: npm test
      continue-on-error: false

    - name: Update PR status on success
      if: success() && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: sha,
            state: 'success',
            description: 'Unit tests passed',
            context: 'tests/unit'
          });

    - name: Update commit status on success
      if: success() && github.event_name != 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const sha = context.sha;
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: sha,
            state: 'success',
            description: 'Unit tests passed',
            context: 'tests/unit'
          });

    - name: Update PR status on failure
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: sha,
            state: 'failure',
            description: 'Unit tests failed',
            context: 'tests/unit'
          });

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: unit-test-results
        path: test-results/
        retention-days: 30

  # Wait for Vercel deployment to complete (only for push events, not PRs)
  wait-for-deployment:
    name: Wait for Vercel Deployment
    runs-on: ubuntu-latest
    needs: unit-tests
    if: |
      github.event_name == 'push' &&
      needs.unit-tests.result == 'success' &&
      !startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: read
      deployments: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Wait for deployment
      id: wait
      uses: actions/github-script@v7
      with:
        script: |
          const branch = context.ref.replace('refs/heads/', '');
          const isMain = branch === 'main';
          const environment = isMain ? 'Production' : 'Preview';
          
          core.info(`Waiting for ${environment} deployment on branch: ${branch} (SHA: ${context.sha})`);
          
          // Try multiple approaches to find deployment
          const maxWaitTime = 300000; // 5 minutes
          const checkInterval = 10000; // 10 seconds
          const startTime = Date.now();
          let foundDeploymentUrl = null;
          
          try {
            while (Date.now() - startTime < maxWaitTime) {
              try {
                // Approach 1: Search by exact ref and environment
                let deployments = await github.rest.repos.listDeployments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.sha,
                  environment: environment,
                  per_page: 5
                });
                
                core.info(`Found ${deployments.data.length} deployment(s) by SHA and environment`);
                
                // Approach 2: If not found, search by branch name and environment
                if (deployments.data.length === 0) {
                  deployments = await github.rest.repos.listDeployments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: branch,
                    environment: environment,
                    per_page: 5
                  });
                  core.info(`Found ${deployments.data.length} deployment(s) by branch and environment`);
                }
                
                // Approach 3: If still not found, search all recent deployments for this environment
                if (deployments.data.length === 0) {
                  const allDeployments = await github.rest.repos.listDeployments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    environment: environment,
                    per_page: 10
                  });
                  
                  // Find deployment matching our commit SHA
                  deployments.data = allDeployments.data.filter(d => d.sha === context.sha);
                  core.info(`Found ${deployments.data.length} deployment(s) by SHA in recent ${environment} deployments`);
                }
                
                if (deployments.data.length > 0) {
                  // Try deployments in order
                  for (const deployment of deployments.data) {
                    try {
                      const { data: statuses } = await github.rest.repos.listDeploymentStatuses({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        deployment_id: deployment.id
                      });
                      
                      if (statuses.length > 0) {
                        const latestStatus = statuses[0];
                        core.info(`Deployment ${deployment.id} status: ${latestStatus.state}, URL: ${latestStatus.target_url || 'none'}`);
                        
                        if (latestStatus.state === 'success' && latestStatus.target_url) {
                          foundDeploymentUrl = latestStatus.target_url;
                          core.info(`‚úÖ Deployment successful: ${foundDeploymentUrl}`);
                          core.setOutput('deployment_url', foundDeploymentUrl);
                          core.setOutput('deployment_environment', environment);
                          core.setOutput('is_fallback', 'false');
                          return;
                        } else if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                          core.warning(`Deployment ${deployment.id} failed: ${latestStatus.state}`);
                          continue; // Try next deployment
                        } else {
                          core.info(`Deployment ${deployment.id} is ${latestStatus.state}, waiting...`);
                        }
                      } else {
                        core.info(`Deployment ${deployment.id} created but no status yet, waiting...`);
                      }
                    } catch (statusError) {
                      core.warning(`Error checking status for deployment ${deployment.id}: ${statusError.message}`);
                      continue;
                    }
                  }
                } else {
                  const elapsed = Math.floor((Date.now() - startTime) / 1000);
                  core.info(`No deployment found yet (waited ${elapsed}s), waiting...`);
                }
              } catch (error) {
                core.warning(`Error checking deployment: ${error.message}`);
              }
              
              await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
          } catch (error) {
            core.error(`Fatal error in deployment wait loop: ${error.message}`);
          }
          
          // Final fallback: If we still don't have a URL, construct one based on branch
          // This is a fallback - it assumes Vercel's URL pattern
          if (!foundDeploymentUrl) {
            core.warning('Could not find deployment via GitHub deployments API after 5 minutes. Using fallback URL construction.');
            const fallbackUrl = isMain 
              ? 'https://sunnyscreen.art'
              : 'https://preview.sunnyscreen.art';
            core.info(`‚ö†Ô∏è Using fallback URL: ${fallbackUrl}`);
            core.info('Note: This may not match the exact deployment URL if Vercel uses custom domains.');
            foundDeploymentUrl = fallbackUrl;
          }
          
          // Always set output, even if using fallback
          if (!foundDeploymentUrl) {
            core.setFailed('Failed to determine deployment URL: no deployment found and fallback failed');
          } else {
            core.setOutput('deployment_url', foundDeploymentUrl);
            core.setOutput('deployment_environment', environment);
            core.setOutput('is_fallback', foundDeploymentUrl.startsWith('https://preview.sunnyscreen.art') || foundDeploymentUrl.startsWith('https://sunnyscreen.art') ? 'true' : 'false');
          }

  # Run E2E tests after deployment completes AND unit tests pass
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [unit-tests, wait-for-deployment]
    if: |
      github.event_name == 'push' &&
      needs.unit-tests.result == 'success' &&
      needs.wait-for-deployment.result == 'success' &&
      !startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: read
      pull-requests: write
      checks: read
      statuses: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20.x
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Install Playwright browsers
      run: npx playwright install --with-deps chromium

    - name: Seed test users
      run: |
        DEPLOYMENT_URL="${{ needs.wait-for-deployment.outputs.deployment_url }}"
        SEED_URL="${DEPLOYMENT_URL}/api/seed-test-users?secret=${{ secrets.SEED_SECRET }}"
        echo "Seeding test users at: ${SEED_URL}"
        curl -X POST "${SEED_URL}" \
          -H "Content-Type: application/json" \
          -H "x-vercel-protection-bypass: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}" \
          || echo "Seed failed, continuing anyway"

    - name: Validate deployment URL
      id: validate-url
      run: |
        DEPLOYMENT_URL="${{ needs.wait-for-deployment.outputs.deployment_url }}"
        if [ -z "$DEPLOYMENT_URL" ]; then
          echo "‚ùå ERROR: Deployment URL is empty!"
          echo "The wait-for-deployment job did not provide a deployment URL."
          echo "This means the deployment was not found or the workflow is misconfigured."
          exit 1
        fi
        echo "‚úÖ Deployment URL: $DEPLOYMENT_URL"

    - name: Run E2E tests
      id: e2e-tests
      env:
        BASE_URL: ${{ needs.wait-for-deployment.outputs.deployment_url }}
        PLAYWRIGHT_BYPASS_HEADER: x-vercel-protection-bypass
        PLAYWRIGHT_BYPASS_VALUE: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
      run: |
        if [ -z "$BASE_URL" ]; then
          echo "‚ùå ERROR: BASE_URL is empty. Cannot run E2E tests."
          exit 1
        fi
        echo "Testing deployment at: $BASE_URL"
        npm run test:e2e:preview
      continue-on-error: false

    - name: Update commit status on success
      if: success()
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: context.sha,
            state: 'success',
            target_url: '${{ needs.wait-for-deployment.outputs.deployment_url }}',
            description: 'E2E tests passed',
            context: 'tests/e2e'
          });

    - name: Update commit status on failure
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: context.sha,
            state: 'failure',
            target_url: '${{ needs.wait-for-deployment.outputs.deployment_url }}',
            description: 'E2E tests failed',
            context: 'tests/e2e'
          });

    - name: Find PR from preview to main (for preview branch)
      id: find-pr-for-status
      if: failure() && github.ref == 'refs/heads/preview'
      uses: actions/github-script@v7
      with:
        script: |
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head: 'preview',
            base: 'main',
            state: 'open'
          });
          
          if (prs.length > 0) {
            const pr = prs[0];
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_sha', pr.head.sha);
            
            // Update PR status to failure
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: pr.head.sha,
              state: 'failure',
              target_url: '${{ needs.wait-for-deployment.outputs.deployment_url }}',
              description: 'E2E tests failed on preview deployment',
              context: 'tests/e2e'
            });
            
            core.info(`Updated PR #${pr.number} status to failure`);
          }

    - name: Report E2E test failure
      if: failure()
      run: |
        echo "‚ùå E2E tests failed"
        echo "üìç Deployment URL: ${{ needs.wait-for-deployment.outputs.deployment_url }}"
        echo "‚è∏Ô∏è  Workflow stopped. Fix issues before retrying."

    - name: Upload E2E test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: e2e-test-results
        path: test-results/
        retention-days: 30

  # Promote to production after E2E tests pass on preview branch
  promote-to-production:
    name: Promote to Production (Auto-merge PR)
    runs-on: ubuntu-latest
    needs: [unit-tests, wait-for-deployment, e2e-tests]
    permissions:
      contents: write
      pull-requests: write
      checks: write
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/preview' &&
      needs.unit-tests.result == 'success' &&
      needs.wait-for-deployment.result == 'success' &&
      needs.e2e-tests.result == 'success' &&
      needs.wait-for-deployment.outputs.deployment_environment != 'Production'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Find PR from preview to main
      id: find-pr
      uses: actions/github-script@v7
      with:
        script: |
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head: 'preview',
            base: 'main',
            state: 'open'
          });
          
          if (prs.length === 0) {
            core.setFailed('No open PR from preview to main found. Please create a PR first.');
            return;
          }
          
          const pr = prs[0];
          core.info(`Found PR #${pr.number}: ${pr.title}`);
          core.setOutput('pr_number', pr.number);
          core.setOutput('pr_sha', pr.head.sha);

    - name: Update PR status - Tests passing
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: '${{ steps.find-pr.outputs.pr_sha }}',
            state: 'success',
            target_url: '${{ needs.wait-for-deployment.outputs.deployment_url }}',
            description: 'All tests passed on preview deployment',
            context: 'tests/e2e'
          });

    - name: Auto-merge PR
      uses: actions/github-script@v7
      with:
        script: |
          const prNumber = ${{ steps.find-pr.outputs.pr_number }};
          
          try {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              commit_title: `Auto-promote preview to production after E2E tests passed`,
              commit_message: `Preview deployment: ${{ needs.wait-for-deployment.outputs.deployment_url }}
          E2E tests: Passed ‚úÖ

          ü§ñ Automated by GitHub Actions`,
              merge_method: 'merge'
            });
            
            core.info(`‚úÖ Successfully merged PR #${prNumber}`);
          } catch (error) {
            if (error.status === 405) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              if (pr.merged) {
                core.info(`PR #${prNumber} was already merged`);
              } else if (!pr.mergeable) {
                core.setFailed(`PR #${prNumber} is not mergeable. Reasons: ${JSON.stringify(pr)}`);
              } else {
                throw error;
              }
            } else {
              throw error;
            }
          }

    - name: Deployment initiated
      run: |
        echo "‚úÖ E2E tests passed on preview"
        echo "üöÄ Auto-merged PR #${{ steps.find-pr.outputs.pr_number }}"
        echo "‚è≥ Vercel will now deploy to production (sunnyscreen.art)"
